import { IntervalTree } from 'diesal';
import L from 'leaflet';

// @ts-ignore
L.Timeline = L.GeoJSON.extend({
    times: null,
    ranges: null,
    initialize(geojson, options = {}) {
        this.times = [];
        this.ranges = new IntervalTree();
        const defaultOptions = {
            drawOnSetTime: true,
        };
        // @ts-ignore
        L.GeoJSON.prototype.initialize.call(this, null, options);
        L.Util.setOptions(this, defaultOptions);
        L.Util.setOptions(this, options);
        if (this.options.getInterval) {
            this._getInterval = (feature) => this.options.getInterval(feature);
        }
        if (geojson) {
            this._process(geojson);
        }
    },
    _getInterval(feature) {
        if (feature.properties &&
            'start' in feature.properties &&
            'end' in feature.properties) {
            const { startExclusive, endExclusive } = feature.properties;
            return {
                start: new Date(feature.properties.start).getTime(),
                end: new Date(feature.properties.end).getTime(),
                startExclusive: startExclusive === true || startExclusive === 'true',
                endExclusive: endExclusive === true || endExclusive === 'true',
            };
        }
        return false;
    },
    /**
     * Finds the first and last times in the dataset, adds all times into an
     * array, and puts everything into an IntervalTree for quick lookup.
     *
     * @param data GeoJSON to process
     */
    _process(data) {
        data.features.forEach((feature) => {
            const interval = this._getInterval(feature);
            if (!interval) {
                return;
            }
            this.ranges.insert(interval.start + (interval.startExclusive ? 1 : 0), interval.end - (interval.endExclusive ? 1 : 0), feature);
            this.times.push(interval.start);
            this.times.push(interval.end);
        });
        if (this.times.length === 0) {
            this.start = this.options.start ?? Infinity;
            this.end = this.options.end ?? -Infinity;
            this.time = this.start;
            return;
        }
        // default sort is lexicographic, even for number types. so need to
        // specify sorting function.
        this.times.sort((a, b) => a - b);
        // de-duplicate the times
        this.times = this.times.reduce((newList, x, i) => {
            if (i === 0) {
                return newList;
            }
            const lastTime = newList[newList.length - 1];
            if (lastTime !== x) {
                newList.push(x);
            }
            return newList;
        }, [this.times[0]]);
        this.start = this.options.start ?? this.times[0];
        this.end = this.options.end ?? this.times[this.times.length - 1];
        this.time = this.start;
    },
    /**
     * Sets the time for this layer.
     *
     * @param time The time to set. Usually a number, but if your
     * data is really time-based then you can pass a string (e.g. '2015-01-01')
     * and it will be processed into a number automatically.
     */
    setTime(time) {
        this.time = typeof time === 'number' ? time : new Date(time).getTime();
        if (this.options.drawOnSetTime) {
            this.updateDisplayedLayers();
        }
        this.fire('change');
    },
    /**
     * Update the layer to show only the features that are relevant at the current
     * time. Usually shouldn't need to be called manually, unless you set
     * `drawOnSetTime` to `false`.
     */
    updateDisplayedLayers() {
        // This loop is intended to help optimize things a bit. First, we find all
        // the features that should be displayed at the current time.
        const features = this.ranges.lookup(this.time);
        const layers = this.getLayers();
        const layersToRemove = [];
        // Then we try to match each currently displayed layer up to a feature. If
        // we find a match, then we remove it from the feature list. If we don't
        // find a match, then the displayed layer is no longer valid at this time.
        // We should remove it.
        layers.forEach((layer) => {
            let found = false;
            for (let j = 0; j < features.length; j++) {
                if (layer.feature === features[j]) {
                    found = true;
                    features.splice(j, 1);
                    break;
                }
            }
            if (!found) {
                layersToRemove.push(layer);
            }
        });
        layersToRemove.forEach((layer) => this.removeLayer(layer));
        // Finally, with any features left, they must be new data! We can add them.
        features.forEach((feature) => this.addData(feature));
    },
});
L.timeline = (geojson, options) => new L.Timeline(geojson, options);

// @ts-ignore
L.TimelineSliderControl = L.Control.extend({
    initialize(options = {}) {
        const defaultOptions = {
            duration: 10000,
            enableKeyboardControls: false,
            enablePlayback: true,
            formatOutput: (output) => `${output || ''}`,
            showTicks: true,
            waitToUpdateMap: false,
            position: 'bottomleft',
            steps: 1000,
            autoPlay: false,
        };
        this.timelines = [];
        L.Util.setOptions(this, defaultOptions);
        L.Util.setOptions(this, options);
        this.start = options.start || 0;
        this.end = options.end || 0;
    },
    /* INTERNAL API *************************************************************/
    /**
     * @private
     * @returns A flat, sorted list of all the times of all layers
     */
    _getTimes() {
        const times = [];
        this.timelines.forEach((timeline) => {
            const timesInRange = timeline.times.filter((time) => time >= this.start && time <= this.end);
            times.push(...timesInRange);
        });
        if (times.length) {
            times.sort((a, b) => a - b);
            const dedupedTimes = [times[0]];
            times.reduce((a, b) => {
                if (a !== b) {
                    dedupedTimes.push(b);
                }
                return b;
            });
            return dedupedTimes;
        }
        return times;
    },
    /**
     * Adjusts start/end/step size. Should be called if any of those might
     * change (e.g. when adding a new layer).
     *
     * @private
     */
    _recalculate() {
        const manualStart = typeof this.options.start !== 'undefined';
        const manualEnd = typeof this.options.end !== 'undefined';
        const duration = this.options.duration;
        let min = Infinity;
        let max = -Infinity;
        this.timelines.forEach((timeline) => {
            if (timeline.start < min) {
                min = timeline.start;
            }
            if (timeline.end > max) {
                max = timeline.end;
            }
        });
        if (!manualStart) {
            this.start = min;
            this._timeSlider.min = (min === Infinity ? 0 : min).toString();
            this._timeSlider.value = this._timeSlider.min;
        }
        if (!manualEnd) {
            this.end = max;
            this._timeSlider.max = (max === -Infinity ? 0 : max).toString();
        }
        this._stepSize = Math.max(1, (this.end - this.start) / this.options.steps);
        this._stepDuration = Math.max(1, duration / this.options.steps);
    },
    /**
     * @private
     * @param findTime The time to find events around
     * @param mode The operating mode.
     * If `mode` is 1, finds the event immediately after `findTime`.
     * If `mode` is -1, finds the event immediately before `findTime`.
     * @returns The time of the nearest event.
     */
    _nearestEventTime(findTime, mode = 1) {
        const times = this._getTimes();
        let retNext = false;
        let lastTime = times[0];
        for (let i = 1; i < times.length; i++) {
            const time = times[i];
            if (retNext) {
                return time;
            }
            if (time >= findTime) {
                if (mode === -1) {
                    return lastTime;
                }
                if (time === findTime) {
                    retNext = true;
                }
                else {
                    return time;
                }
            }
            lastTime = time;
        }
        return lastTime;
    },
    /* DOM CREATION & INTERACTION ***********************************************/
    /**
     * Create all of the DOM for the control.
     *
     * @private
     */
    _createDOM() {
        const classes = [
            'leaflet-control-layers',
            'leaflet-control-layers-expanded',
            'leaflet-timeline-control',
        ];
        const container = L.DomUtil.create('div', classes.join(' '));
        this.container = container;
        if (this.options.enablePlayback) {
            const sliderCtrlC = L.DomUtil.create('div', 'sldr-ctrl-container', container);
            const buttonContainer = L.DomUtil.create('div', 'button-container', sliderCtrlC);
            this._makeButtons(buttonContainer);
            if (this.options.enableKeyboardControls) {
                this._addKeyListeners();
            }
            this._makeOutput(sliderCtrlC);
        }
        this._makeSlider(container);
        if (this.options.showTicks) {
            this._buildDataList(container);
        }
        if (this.options.autoPlay) {
            this._autoPlay();
        }
    },
    /**
     * Add keyboard listeners for keyboard control
     *
     * @private
     */
    _addKeyListeners() {
        this._listener = (ev) => this._onKeydown(ev);
        document.addEventListener('keydown', this._listener);
    },
    /**
     * Remove keyboard listeners
     *
     * @private
     */
    _removeKeyListeners() {
        document.removeEventListener('keydown', this._listener);
    },
    /**
     * Constructs a <datalist>, for showing ticks on the range input.
     *
     * @private
     * @param container The container to which to add the datalist
     */
    _buildDataList(container) {
        this._datalist = L.DomUtil.create('datalist', '', container);
        const idNum = Math.floor(Math.random() * 1000000);
        this._datalist.id = `timeline-datalist-${idNum}`;
        this._timeSlider.setAttribute('list', this._datalist.id);
        this._rebuildDataList();
    },
    /**
     * Reconstructs the <datalist>. Should be called when new data comes in.
     */
    _rebuildDataList() {
        const datalist = this._datalist;
        if (!datalist)
            return;
        while (datalist.firstChild) {
            datalist.removeChild(datalist.firstChild);
        }
        const datalistSelect = L.DomUtil.create('select', '', this._datalist);
        datalistSelect.setAttribute('aria-label', 'List of times');
        this._getTimes().forEach((time) => {
            L.DomUtil.create('option', '', datalistSelect).value = time.toString();
        });
    },
    /**
     * Makes a button with the passed name as a class, which calls the
     * corresponding function when clicked. Attaches the button to container.
     *
     * @private
     * @param container The container to which to add the button
     * @param name The class to give the button and the function to call
     */
    _makeButton(container, name) {
        const button = L.DomUtil.create('button', name, container);
        button.setAttribute('aria-label', name);
        button.addEventListener('click', () => this[name]());
        L.DomEvent.disableClickPropagation(button);
    },
    /**
     * Makes the prev, play, pause, and next buttons
     *
     * @private
     * @param container The container to which to add the buttons
     */
    _makeButtons(container) {
        this._makeButton(container, 'prev');
        this._makeButton(container, 'play');
        this._makeButton(container, 'pause');
        this._makeButton(container, 'next');
    },
    /**
     * DOM event handler to disable dragging on map
     *
     * @private
     */
    _disableMapDragging() {
        this.map.dragging.disable();
    },
    /**
     * DOM event handler to enable dragging on map
     *
     * @private
     */
    _enableMapDragging() {
        this.map.dragging.enable();
    },
    /**
     * Creates the range input
     *
     * @private
     * @param container The container to which to add the input
     */
    _makeSlider(container) {
        const slider = L.DomUtil.create('input', 'time-slider', container);
        slider.setAttribute('aria-label', 'Slider');
        slider.type = 'range';
        slider.min = (this.start || 0).toString();
        slider.max = (this.end || 0).toString();
        slider.value = (this.start || 0).toString();
        this._timeSlider = slider;
        // register events using leaflet for easy removal
        L.DomEvent.on(this._timeSlider, 'mousedown mouseup click touchstart', L.DomEvent.stopPropagation);
        L.DomEvent.on(this._timeSlider, 'change input', this._sliderChanged, this);
        L.DomEvent.on(this._timeSlider, 'mouseenter', this._disableMapDragging, this);
        L.DomEvent.on(this._timeSlider, 'mouseleave', this._enableMapDragging, this);
    },
    _makeOutput(container) {
        this._output = L.DomUtil.create('output', 'time-text', container);
        this._output.innerHTML = this.options.formatOutput(this.start);
    },
    _onKeydown(e) {
        let target = (e.target || e.srcElement);
        if (!/INPUT|TEXTAREA/.test(target.tagName)) {
            switch (e.keyCode || e.which) {
                case 37:
                    this.prev();
                    break;
                case 39:
                    this.next();
                    break;
                case 32:
                    this.toggle();
                    break;
                default:
                    return;
            }
            e.preventDefault();
        }
    },
    _sliderChanged(e) {
        const { target } = e;
        const time = parseFloat(target instanceof HTMLInputElement ? target.value : '0');
        this._setTime(time, e.type);
    },
    _setTime(time, type) {
        this.time = time;
        if (!this.options.waitToUpdateMap || type === 'change') {
            this.timelines.forEach((timeline) => timeline.setTime(time));
        }
        if (this._output) {
            this._output.innerHTML = this.options.formatOutput(time);
        }
    },
    _resetIfTimelinesChanged(oldTimelineCount) {
        if (this.timelines.length !== oldTimelineCount) {
            this._recalculate();
            if (this.options.showTicks) {
                this._rebuildDataList();
            }
            this.setTime(this.start);
        }
    },
    _autoPlay() {
        if (document.readyState === 'loading') {
            window.addEventListener('load', () => this._autoPlay());
        }
        else {
            this.play();
        }
    },
    /* EXTERNAL API *************************************************************/
    /**
     * Register timeline layers with this control. This could change the start and
     * end points of the timeline (unless manually set). It will also reset the
     * playback.
     *
     * @param timelines The `L.Timeline`s to register
     */
    addTimelines(...timelines) {
        this.pause();
        const timelineCount = this.timelines.length;
        timelines.forEach((timeline) => {
            if (this.timelines.indexOf(timeline) === -1) {
                this.timelines.push(timeline);
            }
        });
        this._resetIfTimelinesChanged(timelineCount);
    },
    /**
     * Unregister timeline layers with this control. This could change the start
     * and end points of the timeline unless manually set. It will also reset the
     * playback.
     *
     * @param timelines The `L.Timeline`s to unregister
     */
    removeTimelines(...timelines) {
        this.pause();
        const timelineCount = this.timelines.length;
        timelines.forEach((timeline) => {
            const index = this.timelines.indexOf(timeline);
            if (index !== -1) {
                this.timelines.splice(index, 1);
            }
        });
        this._resetIfTimelinesChanged(timelineCount);
    },
    /**
     * Toggles play/pause state.
     */
    toggle() {
        if (this._playing) {
            this.pause();
        }
        else {
            this.play();
        }
    },
    /**
     * Pauses playback and goes to the previous event.
     */
    prev() {
        this.pause();
        const prevTime = this._nearestEventTime(this.time, -1);
        this._timeSlider.value = prevTime.toString();
        this.setTime(prevTime);
    },
    /**
     * Pauses playback.
     */
    pause(fromSynced) {
        window.clearTimeout(this._timer);
        this._playing = false;
        this.container?.classList.remove('playing');
        if (this.syncedControl && !fromSynced) {
            this.syncedControl.map(function (control) {
                control.pause(true);
            });
        }
    },
    /**
     * Starts playback.
     */
    play(fromSynced) {
        window.clearTimeout(this._timer);
        if (parseFloat(this._timeSlider.value) === this.end) {
            this._timeSlider.value = this.start.toString();
        }
        this._timeSlider.value = (parseFloat(this._timeSlider.value) + this._stepSize).toString();
        this.setTime(+this._timeSlider.value);
        if (parseFloat(this._timeSlider.value) === this.end) {
            this._playing = false;
            this.container?.classList.remove('playing');
        }
        else {
            this._playing = true;
            this.container?.classList.add('playing');
            this._timer = window.setTimeout(() => this.play(true), this._stepDuration);
        }
        if (this.syncedControl && !fromSynced) {
            this.syncedControl.map(function (control) {
                control.play(true);
            });
        }
    },
    /**
     * Pauses playback and goes to the next event.
     */
    next() {
        this.pause();
        const nextTime = this._nearestEventTime(this.time, 1);
        this._timeSlider.value = nextTime.toString();
        this.setTime(nextTime);
    },
    /**
     * Set the time displayed.
     *
     * @param time The time to set
     */
    setTime(time) {
        if (this._timeSlider)
            this._timeSlider.value = time.toString();
        this._setTime(time, 'change');
    },
    onAdd(map) {
        this.map = map;
        this._createDOM();
        this.setTime(this.start);
        return this.container;
    },
    onRemove() {
        /* istanbul ignore else */
        if (this.options.enableKeyboardControls) {
            this._removeKeyListeners();
        }
        // cleanup events registered in _makeSlider
        L.DomEvent.off(this._timeSlider, 'change input', this._sliderChanged, this);
        L.DomEvent.off(this._timeSlider, 'pointerdown mousedown touchstart', this._disableMapDragging, this);
        L.DomEvent.off(document.body, 'pointerup mouseup touchend', this._enableMapDragging, this);
        // make sure that dragging is restored to enabled state
        this._enableMapDragging();
    },
    syncControl(controlToSync) {
        if (!this.syncedControl) {
            this.syncedControl = [];
        }
        this.syncedControl.push(controlToSync);
    },
});
L.timelineSliderControl = (options) => new L.TimelineSliderControl(options);

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".leaflet-control.leaflet-timeline-control {\n  width: 96%;\n  box-sizing: border-box;\n  margin: 2%;\n  margin-bottom: 20px;\n  text-align: center;\n}\n.leaflet-control.leaflet-timeline-control * {\n  vertical-align: middle;\n}\n.leaflet-control.leaflet-timeline-control input[type=\"range\"] {\n  width: 80%;\n}\n.leaflet-control.leaflet-timeline-control .sldr-ctrl-container {\n  float: left;\n  width: 15%;\n  box-sizing: border-box;\n}\n.leaflet-control.leaflet-timeline-control .button-container button {\n  position: relative;\n  width: 20%;\n  height: 20px;\n}\n.leaflet-control.leaflet-timeline-control .button-container button::before,\n.leaflet-control.leaflet-timeline-control .button-container button::after {\n  content: \"\";\n  position: absolute;\n}\n.leaflet-control.leaflet-timeline-control\n  .button-container\n  button.play::before {\n  border: 7px solid transparent;\n  border-width: 7px 0 7px 10px;\n  border-left-color: black;\n  margin-top: -7px;\n  background: transparent;\n  margin-left: -5px;\n}\n.leaflet-control.leaflet-timeline-control .button-container button.pause {\n  display: none;\n}\n.leaflet-control.leaflet-timeline-control\n  .button-container\n  button.pause::before {\n  width: 4px;\n  height: 14px;\n  border: 4px solid black;\n  border-width: 0 4px;\n  margin-top: -7px;\n  margin-left: -6px;\n  background: transparent;\n}\n.leaflet-control.leaflet-timeline-control .button-container button.prev::before,\n.leaflet-control.leaflet-timeline-control .button-container button.prev::after {\n  margin: -8px 0 0;\n  background: black;\n}\n.leaflet-control.leaflet-timeline-control\n  .button-container\n  button.prev::before {\n  width: 2px;\n  height: 14px;\n  margin-top: -7px;\n  margin-left: -7px;\n}\n.leaflet-control.leaflet-timeline-control .button-container button.prev::after {\n  border: 7px solid transparent;\n  border-width: 7px 10px 7px 0;\n  border-right-color: black;\n  margin-top: -7px;\n  margin-left: -5px;\n  background: transparent;\n}\n.leaflet-control.leaflet-timeline-control .button-container button.next::before,\n.leaflet-control.leaflet-timeline-control .button-container button.next::after {\n  margin: -8px 0 0;\n  background: black;\n}\n.leaflet-control.leaflet-timeline-control\n  .button-container\n  button.next::before {\n  width: 2px;\n  height: 14px;\n  margin-top: -7px;\n  margin-left: 5px;\n}\n.leaflet-control.leaflet-timeline-control .button-container button.next::after {\n  border: 7px solid transparent;\n  border-width: 7px 0 7px 10px;\n  border-left-color: black;\n  margin-top: -7px;\n  margin-left: -5px;\n  background: transparent;\n}\n.leaflet-control.leaflet-timeline-control.playing button.pause {\n  display: inline-block;\n}\n.leaflet-control.leaflet-timeline-control.playing button.play {\n  display: none;\n}\n";
styleInject(css_248z);
